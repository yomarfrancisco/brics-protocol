name: ci-audit

on:
  schedule:
    - cron: '13 2 * * 1' # Mondays 02:13 UTC
  workflow_dispatch:

permissions:
  actions: read
  issues: write
  contents: read

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (shallow OK)
        uses: actions/checkout@v3

      - name: CI Health Audit
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // 1) Find the "tests" workflow id
            const { data: wfList } = await github.rest.actions.listRepoWorkflows({ owner, repo, per_page: 100 });
            const testsWf = wfList.workflows.find(w => w.name === 'tests');
            if (!testsWf) {
              core.setFailed('Could not find a workflow named "tests".');
              return;
            }

            // 2) Fetch recent successful runs on main
            const { data: runsData } = await github.rest.actions.listWorkflowRuns({
              owner, repo, workflow_id: testsWf.id, branch: 'main', per_page: 10
            });
            const okRuns = runsData.workflow_runs.filter(r => r.conclusion === 'success');

            // 3) For each run, fetch jobs and extract durations for smokes + test
            const toSecs = ms => Math.round(ms / 1000);
            const jobDurations = [];
            for (const run of okRuns) {
              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner, repo, run_id: run.id, per_page: 100
              });
              const items = jobs.data.jobs.map(j => {
                const started = j.started_at ? new Date(j.started_at).getTime() : null;
                const completed = j.completed_at ? new Date(j.completed_at).getTime() : null;
                const dur = (started && completed) ? toSecs(completed - started) : null;
                return { name: j.name, dur };
              });
              const smokes = items.find(i => /smokes/i.test(i.name));
              const test = items.find(i => /\btest\b/i.test(i.name));
              jobDurations.push({
                run_id: run.id,
                html_url: run.html_url,
                smokes: smokes?.dur ?? null,
                test: test?.dur ?? null
              });
            }

            // 4) Simple medians
            const median = arr => {
              const xs = arr.filter(x => typeof x === 'number').sort((a,b)=>a-b);
              if (xs.length === 0) return null;
              const m = Math.floor(xs.length / 2);
              return xs.length % 2 ? xs[m] : Math.round((xs[m-1] + xs[m]) / 2);
            };
            const smokesMeds = median(jobDurations.map(r => r.smokes));
            const testMeds   = median(jobDurations.map(r => r.test));

            // 5) Timing analysis from artifacts (preferred over run metadata)
            const { execSync } = require('child_process');
            let timingAnalysis = '';
            let usedArtifacts = false;
            
            try {
              // Get recent runs and download timing artifacts
              const recentRuns = okRuns.slice(0, 20); // Last 20 successful runs
              const timingData = [];
              
              for (const run of recentRuns) {
                try {
                  // Try to download timing artifacts
                  execSync(`gh run download ${run.id} -n ci-timings-smokes -D /tmp/timing-${run.id}-smokes 2>/dev/null || true`);
                  execSync(`gh run download ${run.id} -n ci-timings-test -D /tmp/timing-${run.id}-test 2>/dev/null || true`);
                  
                  // Parse timing data
                  const smokesFile = `/tmp/timing-${run.id}-smokes/ci-timings.txt`;
                  const testFile = `/tmp/timing-${run.id}-test/ci-timings.txt`;
                  
                  if (require('fs').existsSync(smokesFile)) {
                    const smokesLine = require('fs').readFileSync(smokesFile, 'utf8').trim();
                    const [, , duration, cacheHit] = smokesLine.split(',');
                    timingData.push({ job: 'smokes', duration: parseInt(duration), cacheHit: cacheHit === 'true', runId: run.id });
                  }
                  
                  if (require('fs').existsSync(testFile)) {
                    const testLine = require('fs').readFileSync(testFile, 'utf8').trim();
                    const [, , duration, cacheHit] = testLine.split(',');
                    timingData.push({ job: 'test', duration: parseInt(duration), cacheHit: cacheHit === 'true', runId: run.id });
                  }
                } catch (e) {
                  // Skip runs without timing data
                }
              }
              
              if (timingData.length > 0) {
                usedArtifacts = true;
                const smokesTimings = timingData.filter(t => t.job === 'smokes').map(t => t.duration);
                const testTimings = timingData.filter(t => t.job === 'test').map(t => t.duration);
                
                const smokesMedian = median(smokesTimings);
                const testMedian = median(testTimings);
                
                // Calculate deltas (placeholder for now)
                const smokesDelta = 'N/A'; // Would need previous median to calculate
                const testDelta = 'N/A';
                
                timingAnalysis = `\n**Timing Analysis (7-day medians from artifacts):**\n- Smokes: ${smokesMedian}s (${smokesDelta})\n- Test: ${testMedian}s (${testDelta})\n`;
              }
            } catch (e) {
              // Fall back to run metadata
            }
            
            if (!usedArtifacts) {
              timingAnalysis = `\n**Timing Analysis (fallback to run metadata):**\n- Smokes: ${smokesMeds ? smokesMeds + 's' : 'n/a'}\n- Test: ${testMeds ? testMeds + 's' : 'n/a'}\n`;
            }

            // 6) Open PRs with failing checks
            const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open', per_page: 50 });
            const failingPRs = [];
            for (const pr of prs) {
              // get combined status + checks
              const sha = pr.head.sha;
              const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
              const failing = (checks.data.check_runs || []).filter(c => c.conclusion === 'failure');
              if (failing.length > 0) {
                failingPRs.push({
                  number: pr.number,
                  title: pr.title,
                  failingCount: failing.length,
                  url: pr.html_url
                });
              }
            }

            // 6) Compose report
            const lines = [];
            lines.push(`### CI Health Report (auto)`);
            lines.push(`**Date:** ${new Date().toISOString().slice(0,19).replace('T',' ')} UTC`);
            lines.push('');
            lines.push(`**Recent Performance (medians across last ${jobDurations.length} successful "tests" runs on main):**`);
            lines.push(`- Smokes: ${smokesMeds ? smokesMeds + 's' : 'n/a'}`);
            lines.push(`- Test: ${testMeds ? testMeds + 's' : 'n/a'}`);
            lines.push(timingAnalysis);
            lines.push('');
            if (jobDurations.length) {
              lines.push(`<details><summary>Sample of recent runs</summary>`);
              for (const r of jobDurations.slice(0,5)) {
                lines.push(`- [Run ${r.run_id}](${r.html_url}) â†’ smokes: ${r.smokes ?? 'n/a'}s, test: ${r.test ?? 'n/a'}s`);
              }
              lines.push(`</details>`);
              lines.push('');
            }
            if (failingPRs.length) {
              lines.push(`**Open PRs with failing checks:**`);
              for (const p of failingPRs) {
                lines.push(`- #${p.number} â€” ${p.title} â€” ${p.failingCount} failing checks (${p.url})`);
              }
            } else {
              lines.push(`**Open PRs with failing checks:** None ðŸŽ‰`);
            }
            lines.push('');
            lines.push(`_This report is generated weekly and on manual dispatch. Source: \`.github/workflows/ci-audit.yml\`._`);

            // 7) Create/update a single rolling issue
            const issueTitle = 'CI Health Report (auto)';
            const { data: existing } = await github.rest.issues.listForRepo({
              owner, repo, state: 'open', per_page: 100
            });
            const match = existing.find(i => i.title === issueTitle);
            if (!match) {
              await github.rest.issues.create({
                owner, repo, title: issueTitle, body: lines.join('\n'),
                labels: ['ci', 'automation']
              });
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number: match.number, body: lines.join('\n')
              });
            }

            core.info('CI audit completed.');
